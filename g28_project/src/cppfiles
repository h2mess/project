/* 
 * Base code for CS 296 Software Systems Lab 
 * Department of Computer Science and Engineering, IIT Bombay
 * Instructor: Parag Chaudhuri
 */

//! These are user defined include files
//! Included in double quotes - the path to find these has to be given at compile time
#include "callbacks.hpp"

#ifndef __APPLE__
#include "GL/glui.h"
#else
#include "GL/glui.h"
#endif

//! The namespace protects the global variables and other names from
//! clashes in scope. Read about the use of named and unnamed
//! namespaces in C++ Figure out where all the datatypes used below
//! are defined
namespace cs296
{
  int32 test_index = 0;
  int32 test_selection = 0;
  int32 test_count = 0;
  cs296::sim_t* entry;
  cs296::base_sim_t* test;
  cs296::settings_t settings;
  int32 width = 640;
  int32 height = 480;
  int32 frame_period = 16;
  int32 main_window;
  float settings_hz = 60.0;
  float32 view_zoom = 1.0f;
  int tx, ty, tw, th;
  bool r_mouse_down;
  b2Vec2 lastp;

  b2Vec2 callbacks_t::convert_screen_to_world(int32 x, int32 y)
  {
    float32 u = x / static_cast<float32>(tw);
    float32 v = (th - y) / float32(th);
    
    float32 ratio = static_cast<float32>(tw) / static_cast<float32>(th);
    b2Vec2 extents(ratio * 25.0f, 25.0f);
    extents *= view_zoom;
    
    b2Vec2 lower = settings.view_center - extents;
    b2Vec2 upper = settings.view_center + extents;
  
    b2Vec2 p;
    p.x = (1.0f - u) * lower.x + u * upper.x;
    p.y = (1.0f - v) * lower.y + v * upper.y;
    return p;
  }
  
  
  void callbacks_t::resize_cb(int32 w, int32 h)
  {
    width = w;
    height = h;
    
    GLUI_Master.get_viewport_area(&tx, &ty, &tw, &th);
    glViewport(tx, ty, tw, th);
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    
    //! Notice the type casting 
    //! Read about explicit/implicit type casting in C++
    float32 ratio = static_cast<float32>(tw) / static_cast<float32>(th);
    
    b2Vec2 extents(ratio * 25.0f, 25.0f);
    extents *= view_zoom;
    
    b2Vec2 lower = settings.view_center - extents;
    b2Vec2 upper = settings.view_center + extents;
  
    //! L/R/B/T extents of the view frustum
    //! Find where this function is defined
    gluOrtho2D(lower.x, upper.x, lower.y, upper.y);
  }
  
  
  void callbacks_t::keyboard_cb(unsigned char key, int x, int y)
  {
    //! What are these?
    B2_NOT_USED(x);
    B2_NOT_USED(y);
    
    switch (key)
    {
    case 27:
      exit(0);
      break;
      
      //! Press 'z' to zoom out.
    case 'z':
      view_zoom = b2Min(1.1f * view_zoom, 20.0f);
      resize_cb(width, height);
      break;
      
    //! Press 'x' to zoom in.
    case 'x':
      view_zoom = b2Max(0.9f * view_zoom, 0.02f);
      resize_cb(width, height);
      break;
      
    //! Press 'r' to reset.
    case 'r':
      delete test;
      test = entry->create_fcn();
      break;
      
      //! Press 'p' to pause.
    case 'p':
      settings.pause = !settings.pause;
      break;
      
      //! The default case. Why is this needed?
    default:
      if (test)
	{
	  test->keyboard(key);
	}
    }
  }
  
  
  void callbacks_t::keyboard_special_cb(int key, int x, int y)
  {
    B2_NOT_USED(x);
    B2_NOT_USED(y);
    
    switch (key)
    {
    case GLUT_ACTIVE_SHIFT:
      
      //! Press left to pan left.
    case GLUT_KEY_LEFT:
      settings.view_center.x -= 0.5f;
      resize_cb(width, height);
      break;
      
    //! Press right to pan right.
    case GLUT_KEY_RIGHT:
      settings.view_center.x += 0.5f;
      resize_cb(width, height);
      break;
      
    //! Press down to pan down.
    case GLUT_KEY_DOWN:
      settings.view_center.y -= 0.5f;
      resize_cb(width, height);
      break;
      
    //! Press up to pan up.
    case GLUT_KEY_UP:
      settings.view_center.y += 0.5f;
      resize_cb(width, height);
      break;
      
    //! Press home to reset the view.
    case GLUT_KEY_HOME:
      view_zoom = 1.0f;
      settings.view_center.Set(0.0f, 20.0f);
      callbacks_t::resize_cb(width, height);
      break;
    }
  }

  void callbacks_t::keyboard_up_cb(unsigned char key, int x, int y)
  {
    B2_NOT_USED(x);
    B2_NOT_USED(y);
    
    if (test)
      {
	test->keyboard_up(key);
      }
  }
  
  void callbacks_t::mouse_cb(int32 button, int32 state, int32 x, int32 y)
  {
    //! Use the mouse to move things around - figure out how this works?
    if (button == GLUT_LEFT_BUTTON)
      {
	int mod = glutGetModifiers();
	b2Vec2 p = convert_screen_to_world(x, y);
	if (state == GLUT_DOWN)
	  {
	    b2Vec2 p = convert_screen_to_world(x, y);
	    if (mod == GLUT_ACTIVE_SHIFT)
	      {
		test->shift_mouse_down(p);
	      }
	    else
	      {
		test->mouse_down(p);
	      }
	  }
	
	if (state == GLUT_UP)
	  {
	    test->mouse_up(p);
	  }
      }
    else if (button == GLUT_RIGHT_BUTTON)
      {
	if (state == GLUT_DOWN)
	  {	
	    lastp = convert_screen_to_world(x, y);
	    r_mouse_down = true;
	  }
	
	if (state == GLUT_UP)
	  {
	  r_mouse_down = false;
	  }
      }
  }
  
  
  void callbacks_t::mouse_motion_cb(int32 x, int32 y)
  {
    b2Vec2 p = convert_screen_to_world(x, y);
    test->mouse_move(p);
    
    if (r_mouse_down)
      {
	b2Vec2 diff = p - lastp;
	settings.view_center.x -= diff.x;
	settings.view_center.y -= diff.y;
	resize_cb(width, height);
	lastp = convert_screen_to_world(x, y);
      }
  }
  
  void callbacks_t::timer_cb(int)
  {
    glutSetWindow(main_window);
    glutPostRedisplay();
    glutTimerFunc(frame_period, timer_cb, 0);
  }
  
  void callbacks_t::display_cb(void)
  {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    test->set_text_line(30);
    b2Vec2 old_center = settings.view_center;
    settings.hz = settings_hz;
    
    test->step(&settings);
    
    if (old_center.x != settings.view_center.x || old_center.y != settings.view_center.y)
      {
	resize_cb(width, height);
      }
    
    test->draw_title(5, 15, entry->name);
    
    glutSwapBuffers();
    
    if (test_selection != test_index)
      {
	test_index = test_selection;
	delete test;
	entry = cs296::sim;
	test = entry->create_fcn();
	view_zoom = 1.0f;
	settings.view_center.Set(0.0f, 20.0f);
      resize_cb(width, height);
      }
  }
  
  
  
  void callbacks_t::restart_cb(int)
  {
    delete test;
    entry = cs296::sim;
    test = entry->create_fcn();
    resize_cb(width, height);
  }
  
  void callbacks_t::pause_cb(int)
  {
    settings.pause = !settings.pause;
  }
  
  void callbacks_t::exit_cb(int code)
  {
    exit(code);
  }
  
  void callbacks_t::single_step_cb(int)
  {
    settings.pause = 1;
    settings.single_step = 1;
  }

};
/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

#include "cs296_base.hpp"
#include <cstdio>
using namespace std;
using namespace cs296;


base_sim_t::base_sim_t()
{
	b2Vec2 gravity;
	gravity.Set(0.0f, -10.0f);
	m_world = new b2World(gravity);

	m_text_line = 30;

	m_point_count = 0;

	m_world->SetDebugDraw(&m_debug_draw);
	
	m_step_count = 0;

	b2BodyDef body_def;
	m_ground_body = m_world->CreateBody(&body_def);

	memset(&m_max_profile, 0, sizeof(b2Profile));
	memset(&m_total_profile, 0, sizeof(b2Profile));
}

base_sim_t::~base_sim_t()
{
	// By deleting the world, we delete the bomb, mouse joint, etc.
	delete m_world;
	m_world = NULL;
}

void base_sim_t::pre_solve(b2Contact* contact, const b2Manifold* oldManifold)
{
  const b2Manifold* manifold = contact->GetManifold();
  
  if (manifold->pointCount == 0)
    {
      return;
    }
  
  b2Fixture* fixtureA = contact->GetFixtureA();
  b2Fixture* fixtureB = contact->GetFixtureB();
  
  b2PointState state1[b2_maxManifoldPoints], state2[b2_maxManifoldPoints];
  b2GetPointStates(state1, state2, oldManifold, manifold);
  
  b2WorldManifold world_manifold;
  contact->GetWorldManifold(&world_manifold);
  
  for (int32 i = 0; i < manifold->pointCount && m_point_count < k_max_contact_points; ++i)
    {
      contact_point_t* cp = m_points + m_point_count;
      cp->fixtureA = fixtureA;
      cp->fixtureB = fixtureB;
      cp->position = world_manifold.points[i];
      cp->normal = world_manifold.normal;
      cp->state = state2[i];
      ++m_point_count;
    }
}

void base_sim_t::draw_title(int x, int y, const char *string)
{
    m_debug_draw.DrawString(x, y, string);
}

void base_sim_t::step(settings_t* settings)
{
  float32 time_step = settings->hz > 0.0f ? 1.0f / settings->hz : float32(0.0f);

  if (settings->pause)
    {
      if (settings->single_step)
	{
	  settings->single_step = 0;
	}
      else
	{
	  time_step = 0.0f;
	}
      
      m_debug_draw.DrawString(5, m_text_line, "****PAUSED****");
      m_text_line += 15;
    }
  
  uint32 flags = 0;
  flags += settings->draw_shapes			* b2Draw::e_shapeBit;
  flags += settings->draw_joints			* b2Draw::e_jointBit;
  flags += settings->draw_AABBs			* b2Draw::e_aabbBit;
  flags += settings->draw_pairs			* b2Draw::e_pairBit;
  flags += settings->draw_COMs				* b2Draw::e_centerOfMassBit;
  m_debug_draw.SetFlags(flags);
  
  m_world->SetWarmStarting(settings->enable_warm_starting > 0);
  m_world->SetContinuousPhysics(settings->enable_continuous > 0);
  m_world->SetSubStepping(settings->enable_sub_stepping > 0);
  
  m_point_count = 0;
  
  m_world->Step(time_step, settings->velocity_iterations, settings->position_iterations);
  
  m_world->DrawDebugData();
  
  if (time_step > 0.0f)
    {
      ++m_step_count;
    }
  
  if (settings->draw_stats)
    {
      int32 body_count = m_world->GetBodyCount();
      int32 contact_count = m_world->GetContactCount();
      int32 joint_count = m_world->GetJointCount();
      m_debug_draw.DrawString(5, m_text_line, "bodies/contacts/joints = %d/%d/%d", body_count, contact_count, joint_count);
      m_text_line += 15;
      
      int32 proxy_count = m_world->GetProxyCount();
      int32 height = m_world->GetTreeHeight();
      int32 balance = m_world->GetTreeBalance();
      float32 quality = m_world->GetTreeQuality();
      m_debug_draw.DrawString(5, m_text_line, "proxies/height/balance/quality = %d/%d/%d/%g", proxy_count, height, balance, quality);
      m_text_line += 15;
    }
  
  // Track maximum profile times
  {
    const b2Profile& p = m_world->GetProfile();
    m_max_profile.step = b2Max(m_max_profile.step, p.step);
    m_max_profile.collide = b2Max(m_max_profile.collide, p.collide);
    m_max_profile.solve = b2Max(m_max_profile.solve, p.solve);
    m_max_profile.solveInit = b2Max(m_max_profile.solveInit, p.solveInit);
    m_max_profile.solveVelocity = b2Max(m_max_profile.solveVelocity, p.solveVelocity);
    m_max_profile.solvePosition = b2Max(m_max_profile.solvePosition, p.solvePosition);
    m_max_profile.solveTOI = b2Max(m_max_profile.solveTOI, p.solveTOI);
    m_max_profile.broadphase = b2Max(m_max_profile.broadphase, p.broadphase);
    
    m_total_profile.step += p.step;
    m_total_profile.collide += p.collide;
    m_total_profile.solve += p.solve;
    m_total_profile.solveInit += p.solveInit;
    m_total_profile.solveVelocity += p.solveVelocity;
    m_total_profile.solvePosition += p.solvePosition;
    m_total_profile.solveTOI += p.solveTOI;
    m_total_profile.broadphase += p.broadphase;
  }
  
  if (settings->draw_profile)
    {
      const b2Profile& p = m_world->GetProfile();
      
      b2Profile ave_profile;
      memset(&ave_profile, 0, sizeof(b2Profile));
      if (m_step_count > 0)
	{
	  float32 scale = 1.0f / m_step_count;
	  ave_profile.step = scale * m_total_profile.step;
	  ave_profile.collide = scale * m_total_profile.collide;
	  ave_profile.solve = scale * m_total_profile.solve;
	  ave_profile.solveInit = scale * m_total_profile.solveInit;
	  ave_profile.solveVelocity = scale * m_total_profile.solveVelocity;
	  ave_profile.solvePosition = scale * m_total_profile.solvePosition;
	  ave_profile.solveTOI = scale * m_total_profile.solveTOI;
	  ave_profile.broadphase = scale * m_total_profile.broadphase;
	}
      
      m_debug_draw.DrawString(5, m_text_line, "step [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.step, ave_profile.step, m_max_profile.step);
      m_text_line += 15;
      m_debug_draw.DrawString(5, m_text_line, "collide [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.collide, ave_profile.collide, m_max_profile.collide);
      m_text_line += 15;
      m_debug_draw.DrawString(5, m_text_line, "solve [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.solve, ave_profile.solve, m_max_profile.solve);
      m_text_line += 15;
      m_debug_draw.DrawString(5, m_text_line, "solve init [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.solveInit, ave_profile.solveInit, m_max_profile.solveInit);
      m_text_line += 15;
      m_debug_draw.DrawString(5, m_text_line, "solve velocity [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.solveVelocity, ave_profile.solveVelocity, m_max_profile.solveVelocity);
      m_text_line += 15;
      m_debug_draw.DrawString(5, m_text_line, "solve position [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.solvePosition, ave_profile.solvePosition, m_max_profile.solvePosition);
      m_text_line += 15;
      m_debug_draw.DrawString(5, m_text_line, "solveTOI [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.solveTOI, ave_profile.solveTOI, m_max_profile.solveTOI);
      m_text_line += 15;
      m_debug_draw.DrawString(5, m_text_line, "broad-phase [ave] (max) = %5.2f [%6.2f] (%6.2f)", p.broadphase, ave_profile.broadphase, m_max_profile.broadphase);
      m_text_line += 15;
    }
    
  if (settings->draw_contact_points)
    {
      //const float32 k_impulseScale = 0.1f;
      const float32 k_axis_scale = 0.3f;
      
      for (int32 i = 0; i < m_point_count; ++i)
	{
	  contact_point_t* point = m_points + i;
	  
	  if (point->state == b2_addState)
	    {
	      // Add
	      m_debug_draw.DrawPoint(point->position, 10.0f, b2Color(0.3f, 0.95f, 0.3f));
	    }
	  else if (point->state == b2_persistState)
	    {
	      // Persist
	      m_debug_draw.DrawPoint(point->position, 5.0f, b2Color(0.3f, 0.3f, 0.95f));
	    }
	  
	  if (settings->draw_contact_normals == 1)
	    {
	      b2Vec2 p1 = point->position;
	      b2Vec2 p2 = p1 + k_axis_scale * point->normal;
	      m_debug_draw.DrawSegment(p1, p2, b2Color(0.9f, 0.9f, 0.9f));
	    }
	  else if (settings->draw_contact_forces == 1)
	    {
	      //b2Vec2 p1 = point->position;
	      //b2Vec2 p2 = p1 + k_forceScale * point->normalForce * point->normal;
	      //DrawSegment(p1, p2, b2Color(0.9f, 0.9f, 0.3f));
	    }
	  
	  if (settings->draw_friction_forces == 1)
	    {
	      //b2Vec2 tangent = b2Cross(point->normal, 1.0f);
	      //b2Vec2 p1 = point->position;
	      //b2Vec2 p2 = p1 + k_forceScale * point->tangentForce * tangent;
	      //DrawSegment(p1, p2, b2Color(0.9f, 0.9f, 0.3f));
	    }
	}
    }
}
/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

/* 
 * Base code for CS 296 Software Systems Lab 
 * Department of Computer Science and Engineering, IIT Bombay
 * Instructor: Parag Chaudhuri
 */


#include "cs296_base.hpp"
#include "render.hpp"

#ifdef __APPLE__
	#include <GLUT/glut.h>
#else
	#include "GL/freeglut.h"
#endif

#include <cstring>
using namespace std;

#include "dominos.hpp"

namespace cs296
{
  /**  The is the constructor 
   * This is the documentation block for the constructor.
   */ 
//  float wheelRadius = 1;
	float screenWidth = 90; //This is used in main code. This is also half of what is used may be
	float groundHeight = 0.5; //this is half of the ground height because, function doubles it
	float pebbleHeight = groundHeight/2;//same as above. This is also half of it.
	int pebbleNumber = 15;
	float pebbleWidth = 2;
	float wheelRadius = 6;
	float gap = wheelRadius*3;//this is gap between centers of wheels
	float firstWheelCenterx = 0;//this is x position of center of first wheel
	float rodWidth = 1;
  dominos_t::dominos_t()
  {
	  //This is for creating ground with those brown steps

    b2Body* b1;  
    {
      
      b2PolygonShape groundShape; 
      groundShape.SetAsBox(screenWidth,groundHeight);
      b2BodyDef bd; 
      b1 = m_world->CreateBody(&bd);
	  b2FixtureDef groundFixtureDef;
	  groundFixtureDef.shape = &groundShape;
	  groundFixtureDef.friction = 0.5;
      b1->CreateFixture(&groundFixtureDef);
	  b2BodyDef pebbleDef; //These brown rectangles at the bottom of picture are called pebbles
	  b2PolygonShape pebbleShape;
	  pebbleShape.SetAsBox(pebbleWidth,pebbleHeight);//
	  b2Body* pebbles[pebbleNumber];
	  pebbleDef.position.Set(-screenWidth,-groundHeight-pebbleHeight);
	  for(int i=0;i<pebbleNumber;i++){
		  pebbles[i] = (*m_world).CreateBody(&pebbleDef);
		  pebbleDef.position.Set(-screenWidth+(i+1)*(2*screenWidth/pebbleNumber), -groundHeight-pebbleHeight);
		 (*pebbles[i]).CreateFixture(&pebbleShape, 0.0f);
	  }
	  b2FixtureDef pebbleFixtureDef;
	  pebbleFixtureDef.shape = &pebbleShape;
    }
        //upto here  
	//Here starts remaking of wheel :P
	b2CircleShape wheelShape;
	wheelShape.m_p.Set(0,0);
	wheelShape.m_radius = wheelRadius;
	b2BodyDef wheelBodyDef;
	wheelBodyDef.type = b2_dynamicBody;		
	wheelBodyDef.position.Set(firstWheelCenterx,groundHeight+wheelRadius);
	b2Body* wheelBody1 = (*m_world).CreateBody(&wheelBodyDef);
	b2FixtureDef wheelFixtureDef;
//	wheelFixtureDef.restitution = 0;
	wheelFixtureDef.shape = &wheelShape;
	(*wheelBody1).CreateFixture(&wheelFixtureDef);
	//wheel is made!!
	//How about a second wheel
	wheelBodyDef.position.Set(firstWheelCenterx+gap, groundHeight+wheelRadius);//this is actually 0+gap
	b2Body* wheelBody2 = (*m_world).CreateBody(&wheelBodyDef);
	(*wheelBody2).CreateFixture(&wheelFixtureDef);
	//One more wheel (not for nothing)
	wheelBodyDef.position.Set(firstWheelCenterx+gap+gap, groundHeight+wheelRadius);
	b2Body* wheelBody3 = (*m_world).CreateBody(&wheelBodyDef);
	(*wheelBody3).CreateFixture(&wheelFixtureDef);

	//Second victory!!
	//Here starts the joint for a wheel
/*	b2PolygonShape concShape;
	concShape.SetAsBox(0.5,2);
	b2BodyDef concBodyDef;
	concBodyDef.type = b2_dynamicBody;
	concBodyDef.angle = -0.7;
	concBodyDef.position.Set(wheelRadius*2,wheelRadius);
	b2Body* concBody = (*m_world).CreateBody(&concBodyDef);
	b2FixtureDef concFixtureDef;
//	concFixtureDef.density = 1000;
	concFixtureDef.shape = &concShape;
	(*concBody).CreateFixture(&concFixtureDef);
	//Now, the joint between those two
	b2RevoluteJointDef concJointDef;
	concJointDef.bodyA = concBody;
	concJointDef.bodyB = wheelBody1;
	concJointDef.localAnchorB.Set(wheelRadius/2,wheelRadius/2);
	concJointDef.localAnchorA.Set(-1,-1);
	(b2RevoluteJoint*)m_world->CreateJoint(&concJointDef);*/
	/*Now, we need to make a rod between circle1 and circle3. Let point on circle1 be called a and point on circle 3 be called b. we connect a to c1 by using revolute joint, similarly for b and c3. This ensures that the system is setup. First work is to setup a and b. Qns are 
	1. How do you locate a, b(It must be responsive. So, no hardcoding)
	2. How can we make revolute joints?(We have to give anchor points relative to bodies)
	*/
	
	  ///chalo, chalo, chalo
	b2PolygonShape otrodShape;
	otrodShape.SetAsBox(gap, rodWidth/2);
	b2BodyDef otrodBodyDef;
	otrodBodyDef.type = b2_dynamicBody;
	otrodBodyDef.position.Set(firstWheelCenterx+(wheelRadius/2)+gap, wheelRadius*1.5+groundHeight);
	b2Body* otrodBody = (*m_world).CreateBody(&otrodBodyDef);
	b2FixtureDef otrodFixtureDef;
	otrodFixtureDef.shape = &otrodShape;
	(*otrodBody).CreateFixture(&otrodFixtureDef);
	/*b2RevoluteJointDef onethreeDef;
	onethreeDef.bodyA = wheelBody1;
	onethreeDef.bodyB = wheelBody3;
	onethreeDef.localAnchorA.Set(-wheelRadius/2,
*/
  }

  sim_t *sim = new sim_t("Dominos", dominos_t::create);
}
/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

/* 
 * Base code for CS 296 Software Systems Lab 
 * Department of Computer Science and Engineering, IIT Bombay
 * Instructor: Parag Chaudhuri
 */

//! These are user defined include files
//! Included in double quotes - the path to find these has to be given at compile time
#include "render.hpp"
#include "cs296_base.hpp"
#include "callbacks.hpp"

//! GLUI is the library used for drawing the GUI
//! Learn more about GLUI by reading the GLUI documentation
//! Learn to use preprocessor diectives to make your code portable
#ifndef __APPLE__
#include "GL/glui.h"
#else
#include "GL/glui.h"
#endif

//! These are standard include files
//! These are usually available at standard system paths like /usr/include
//! Read about the use of include files in C++
#include <cstdio>


//! Notice the use of extern. Why is it used here?
namespace cs296
{
  extern int32 test_index;
  extern int32 test_selection;
  extern int32 test_count;
  extern cs296::sim_t* entry;
  extern cs296::base_sim_t* test;
  extern cs296::settings_t settings;
  extern const int32 frame_period;
  extern float settings_hz;
  extern int32 width;
  extern int32 height;
  extern int32 main_window;
};

//! This opens up the cs296 namespace
//! What is the consequence of opening up a namespace?
using namespace cs296;


//! This function creates all the GLUI gui elements
void create_glui_ui(void)
{
  GLUI *glui = GLUI_Master.create_glui_subwindow( main_window, GLUI_SUBWINDOW_BOTTOM );
  
  glui->add_statictext("Simulation Timesteps"); 
  GLUI_Spinner* velocityIterationSpinner =
    glui->add_spinner("Velocity Iterations", GLUI_SPINNER_INT, &settings.velocity_iterations);
  velocityIterationSpinner->set_int_limits(1, 500);
  
  GLUI_Spinner* positionIterationSpinner =
    glui->add_spinner("Position Iterations", GLUI_SPINNER_INT, &settings.position_iterations);
  positionIterationSpinner->set_int_limits(0, 100);
  
  GLUI_Spinner* hertzSpinner =
    glui->add_spinner("Sim steps per frame", GLUI_SPINNER_FLOAT, &settings_hz);
  hertzSpinner->set_float_limits(5.0f, 200.0f);


  
  new GLUI_Column( glui, false );
  glui->add_statictext("Simulation Parameters"); 
  glui->add_checkbox("Warm Starting", &settings.enable_warm_starting);
  glui->add_checkbox("Time of Impact", &settings.enable_continuous);
  glui->add_checkbox("Sub-Stepping", &settings.enable_sub_stepping);


  
  new GLUI_Column( glui, false );
  glui->add_statictext("Display Options"); 
  GLUI_Panel* drawPanel =	glui->add_panel("Draw");
  glui->add_checkbox_to_panel(drawPanel, "Shapes", &settings.draw_shapes);
  glui->add_checkbox_to_panel(drawPanel, "Joints", &settings.draw_joints);
  glui->add_checkbox_to_panel(drawPanel, "AABBs", &settings.draw_AABBs);
  glui->add_checkbox_to_panel(drawPanel, "Statistics", &settings.draw_stats);
  glui->add_checkbox_to_panel(drawPanel, "Profile", &settings.draw_profile);
  
  new GLUI_Column( glui, false );
  glui->add_button("Pause", 0, callbacks_t::pause_cb);
  glui->add_button("Single Step", 0, callbacks_t::single_step_cb);
  glui->add_button("Restart", 0, callbacks_t::restart_cb);
  
  glui->add_button("Quit", 0,(GLUI_Update_CB)callbacks_t::exit_cb);
  glui->set_main_gfx_window( main_window );
}


//! This is the main function
int main(int argc, char** argv)
{
  test_count = 1;
  test_index = 0;
  test_selection = test_index;
  
  entry = sim;
  test = entry->create_fcn();

  //! This initializes GLUT
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
  glutInitWindowSize(width, height);

  char title[50];
  sprintf(title, "CS296 Base Code. Running on Box2D %d.%d.%d", b2_version.major, b2_version.minor, b2_version.revision);
  main_window = glutCreateWindow(title);

  //! Here we setup all the callbacks we need
  //! Some are set via GLUI
  GLUI_Master.set_glutReshapeFunc(callbacks_t::resize_cb);  
  GLUI_Master.set_glutKeyboardFunc(callbacks_t::keyboard_cb);
  GLUI_Master.set_glutSpecialFunc(callbacks_t::keyboard_special_cb);
  GLUI_Master.set_glutMouseFunc(callbacks_t::mouse_cb);
  //! Others are set directly
  glutDisplayFunc(callbacks_t::display_cb);
  glutMotionFunc(callbacks_t::mouse_motion_cb);
  glutKeyboardUpFunc(callbacks_t::keyboard_up_cb); 
  glutTimerFunc(frame_period, callbacks_t::timer_cb, 0);

  //! We create the GLUI user interface
  create_glui_ui();

  //! Enter the infinite GLUT event loop
  glutMainLoop();
  
  return 0;
}
/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

/* 
 * Base code for CS 296 Software Systems Lab 
 * Department of Computer Science and Engineering, IIT Bombay
 * Instructor: Parag Chaudhuri
 */

#include "render.hpp"

#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/freeglut.h>
#endif

#include <cstdio>
#include <cstdarg>
#include <cstring>

using namespace std;

void debug_draw_t::DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color)
{
	glColor3f(color.r, color.g, color.b);
	glBegin(GL_LINE_LOOP);
	for (int32 i = 0; i < vertexCount; ++i)
	{
		glVertex2f(vertices[i].x, vertices[i].y);
	}
	glEnd();
}

void debug_draw_t::DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color)
{
	glEnable(GL_BLEND);
	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glColor4f(0.5f * color.r, 0.5f * color.g, 0.5f * color.b, 0.5f);
	glBegin(GL_TRIANGLE_FAN);
	for (int32 i = 0; i < vertexCount; ++i)
	{
		glVertex2f(vertices[i].x, vertices[i].y);
	}
	glEnd();
	glDisable(GL_BLEND);

	glColor4f(color.r, color.g, color.b, 1.0f);
	glBegin(GL_LINE_LOOP);
	for (int32 i = 0; i < vertexCount; ++i)
	{
		glVertex2f(vertices[i].x, vertices[i].y);
	}
	glEnd();
}

void debug_draw_t::DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color)
{
	const float32 k_segments = 16.0f;
	const float32 k_increment = 2.0f * b2_pi / k_segments;
	float32 theta = 0.0f;
	glColor3f(color.r, color.g, color.b);
	glBegin(GL_LINE_LOOP);
	for (int32 i = 0; i < k_segments; ++i)
	{
		b2Vec2 v = center + radius * b2Vec2(cosf(theta), sinf(theta));
		glVertex2f(v.x, v.y);
		theta += k_increment;
	}
	glEnd();
}

void debug_draw_t::DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color)
{
	const float32 k_segments = 16.0f;
	const float32 k_increment = 2.0f * b2_pi / k_segments;
	float32 theta = 0.0f;
	glEnable(GL_BLEND);
	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glColor4f(0.5f * color.r, 0.5f * color.g, 0.5f * color.b, 0.5f);
	glBegin(GL_TRIANGLE_FAN);
	for (int32 i = 0; i < k_segments; ++i)
	{
		b2Vec2 v = center + radius * b2Vec2(cosf(theta), sinf(theta));
		glVertex2f(v.x, v.y);
		theta += k_increment;
	}
	glEnd();
	glDisable(GL_BLEND);

	theta = 0.0f;
	glColor4f(color.r, color.g, color.b, 1.0f);
	glBegin(GL_LINE_LOOP);
	for (int32 i = 0; i < k_segments; ++i)
	{
		b2Vec2 v = center + radius * b2Vec2(cosf(theta), sinf(theta));
		glVertex2f(v.x, v.y);
		theta += k_increment;
	}
	glEnd();

	b2Vec2 p = center + radius * axis;
	glBegin(GL_LINES);
	glVertex2f(center.x, center.y);
	glVertex2f(p.x, p.y);
	glEnd();
}

void debug_draw_t::DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color)
{
	glColor3f(color.r, color.g, color.b);
	glBegin(GL_LINES);
	glVertex2f(p1.x, p1.y);
	glVertex2f(p2.x, p2.y);
	glEnd();
}

void debug_draw_t::DrawTransform(const b2Transform& xf)
{
	b2Vec2 p1 = xf.p, p2;
	const float32 k_axisScale = 0.4f;
	glBegin(GL_LINES);
	
	glColor3f(1.0f, 0.0f, 0.0f);
	glVertex2f(p1.x, p1.y);
	p2 = p1 + k_axisScale * xf.q.GetXAxis();
	glVertex2f(p2.x, p2.y);

	glColor3f(0.0f, 1.0f, 0.0f);
	glVertex2f(p1.x, p1.y);
	p2 = p1 + k_axisScale * xf.q.GetYAxis();
	glVertex2f(p2.x, p2.y);

	glEnd();
}

void debug_draw_t::DrawPoint(const b2Vec2& p, float32 size, const b2Color& color)
{
	glPointSize(size);
	glBegin(GL_POINTS);
	glColor3f(color.r, color.g, color.b);
	glVertex2f(p.x, p.y);
	glEnd();
	glPointSize(1.0f);
}

void debug_draw_t::DrawString(int x, int y, const char *string, ...)
{
	char buffer[128];

	va_list arg;
	va_start(arg, string);
	vsprintf(buffer, string, arg);
	va_end(arg);

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	int w = glutGet(GLUT_WINDOW_WIDTH);
	int h = glutGet(GLUT_WINDOW_HEIGHT);
	gluOrtho2D(0, w, h, 0);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

	glColor3f(0.9f, 0.6f, 0.6f);
	glRasterPos2i(x, y);
	int32 length = (int32)strlen(buffer);
	for (int32 i = 0; i < length; ++i)
	{
		glutBitmapCharacter(GLUT_BITMAP_8_BY_13, buffer[i]);
	}

	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
}

void debug_draw_t::DrawAABB(b2AABB* aabb, const b2Color& c)
{
	glColor3f(c.r, c.g, c.b);
	glBegin(GL_LINE_LOOP);
	glVertex2f(aabb->lowerBound.x, aabb->lowerBound.y);
	glVertex2f(aabb->upperBound.x, aabb->lowerBound.y);
	glVertex2f(aabb->upperBound.x, aabb->upperBound.y);
	glVertex2f(aabb->lowerBound.x, aabb->upperBound.y);
	glEnd();
}
